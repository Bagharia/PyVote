creation_date et end_date stockées en datetime

Utiliser enum aussi pour "sexe" et "active_user"
--> restreindre les valeurs : "male", "female"



Ajout des relations logiques entre Users et Ballots (n à 1, 1 à n...)

Nous avons 2 collections : 

Ballots (scrutins)
Gère toutes les informations relatives aux scrutins
Description des champs : 
active_poll : si le sondage est en cours, terminé
algorithm_type : le type de l'algorithme (Condercet, majoritaire...)


Users
Gère les participants et les organisateurs
ajout de role (admin, user)
active_user : active, suspended, deleted,
creation_polls : la liste des scrutins créées par un user ou admin

Intégration des relation logiques entre les collections : 
-Un poll(ballot) est créé par un user/admin
-Un poll a des participants (users).
-Un poll peut être modéré par un admin.
-Les résultats d’un poll dépendent d’un algorithme choisi.


Les relations dynamiques entre utilisateurs et scrutins.
Les requêtes MongoDB nécessaires pour extraire les données efficacement (exemple : statistiques, modération, etc.).

Commande MongoDB
use electiondb
db.Ballots/Users.insert...
db.find()

Test de validation des relations entre Users et Ballots : 
- récupération des scrutins créé par un utilisateur
db.Ballots.find({ "created_by": "user_id_001" });

- récupération des scrutins où un utilisateur a voté
db.Ballots.find({ "participants.user_id": "user_id_002" });

- récupération de tous les utilisateurs ayant voté pour un candidat
db.Ballots.aggregate([
  { $match: { "poll_response": "Candidat A" } },
  { $unwind: "$participants" },
  { $match: { "participants.vote": "Candidat A" } },
  { $project: { "participants.user_id": 1 } }
]);

Simulation cas d'utilisation avec des données fictives
Ballots :
-  id 2 : scrutin en cours avec peu de votes
- id 3 : scrutin terminé avec un vainqueur
- id 4 : scrutin sans votes

Users : 
id 2 et 3
